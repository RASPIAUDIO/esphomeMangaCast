substitutions:
  name: mangacast
  friendly_name: Manga
#States  
  P_starting: "0"
  P_waiting: "1"
  P_playing: "2"
  P_listening: "3"
  P_answering: "4"
  
esphome:
  name: ${name}
  friendly_name: ${friendly_name}
  min_version: 2025.2.0
  name_add_mac_suffix: false
  platformio_options:
    board_build.flash_mode: dio
    board_build.arduino.memory_type: qio_opi
  project:
    name: raspiaudio.voice-assistant
    version: "2025.3.0"    
  on_boot:      
    - priority: -100.0
      then:
          - output.turn_on: dac_mute
          - lambda: id(muteH) = true;
          - lambda: id(phase) = 0;
          - lambda: |- 
               id(my_display).print(8, 20, id(my_font) , "RASPIAUDIO");           
          - script.execute: update_led  
       

            
        
esp32:
  board: esp-wrover-kit  
  flash_size: 4MB
  partitions: manga_partitions.csv  
  framework:
    type: esp-idf
    version: recommended
    sdkconfig_options:
      CONFIG_ESP_CONSOLE_USB_CDC: "n"
      CONFIG_ESP_CONSOLE_UART_DEFAULT: "y"
      CONFIG_ESP_CONSOLE_UART_NUM: "0"
      CONFIG_ESP_CONSOLE_UART_BAUDRATE: "115200"
       
micro_wake_word:
  id: mww
  microphone: manga_mic
  stop_after_detection: false
  models:
    - model: https://github.com/kahrendt/microWakeWord/releases/download/okay_nabu_20241226.3/okay_nabu.json
      id: okay_nabu
    - model: hey_jarvis
      id: hey_jarvis
    - model: hey_mycroft
      id: hey_mycroft
  on_wake_word_detected:
    - logger.log: "WW"
    - voice_assistant.start:
        wake_word: !lambda return wake_word;

ota:                 
  - platform: esphome
    id: ota_esphome
  - platform: http_request
    id: ota_http_request
 
update:
  - platform: http_request
    id: update_http_request
    name: Firmware
#    source: https://raw.githubusercontent.com/RASPIAUDIO/raspiaudio.github.io/main/MuseRadio/Homeassistant/manifest_update.json
    source: https://raw.githubusercontent.com/RASPIAUDIO/esphomeLuxe/main/manifest_update.json     
    
http_request:  
    
api:

wifi:
#  ssid: 
#  password: 
  power_save_mode: none
  output_power: 15
  ap:
     ssid: "Raspiaudio-manga"
     password: "12345678"

captive_portal:
                
improv_serial:  # Disable during debugging to free UART0 for logs

logger:
  level: DEBUG
  baud_rate: 115200
  hardware_uart: UART0
  logs:
    media_player: WARN

   
psram:
  mode: quad
  speed: 80MHz
  
i2c:
  sda: GPIO18
  scl: GPIO23
  
font:
  - file: "FormiqRegular-vn037.otf"
    id: my_font
    size: 20
    bpp: 2
  - file: "FormiqRegular-vn037.otf"
    id: my_font2
    size: 20
    bpp: 1    
  
  
display:
  - platform: ssd1306_i2c
    id: my_display
    model: "SH1106_128x64"
    address: 0x3C


#####################
# Internal Components
output:
  - platform: gpio
    id: dac_mute
    pin:
      number: GPIO21
      inverted: true
      mode:
        output: true
  
              
globals:
  - id: Vol
    type: float
    initial_value: '0.6'    
  - id: phase
    type: int
    initial_value: '0'    
  - id: mute  
    type: bool
    initial_value: 'false'        
  - id: muteH 
    type: bool
    initial_value: 'false'     
  - id: last_led_phase
    type: int
    initial_value: '-1'
  - id: audio_active
    type: bool
    initial_value: 'false'
  - id: audio_started
    type: bool
    initial_value: 'false'
  - id: last_volume_cmd
    type: float
    initial_value: '-1.0'
  - id: mic_muted
    type: bool
    initial_value: 'false'
  - id: auto_mute_active
    type: bool
    initial_value: 'false'
  - id: volume_display_active
    type: bool
    initial_value: 'false'
  - id: volume_display_timer
    type: int        
interval:
  - interval: 0.1sec   
    then:          
      - if:
          condition:  
             - speaker.is_stopped:             
          then:
             - if:
                condition:
                  - not:
                     - lambda: 'return(id(muteH));'            
                then:
                  - output.turn_on: dac_mute   
                  - lambda: id(muteH) = true;
                  - logger.log: "====> hardware mute"     
          
      - if:
          condition:  
             - speaker.is_playing:             
          then:
             - if:
                condition:
                  - lambda: 'return(id(muteH));'            
                then:
                  - output.turn_off: dac_mute   
                  - lambda: id(muteH) = false;          
                  - logger.log: "====> hardware unmute"               
     
      - if:
          condition:
            and:
              - lambda: 'return id(audio_active) && !id(audio_started);'
              - speaker.is_playing:
          then:
            - lambda: id(audio_started) = true;
          

sensor:
  - platform: rotary_encoder
    name: "Volume"
    id: volume_encoder
    pin_a:
      number: GPIO19
      mode:
        input: true
        pullup: true
    pin_b:
      number: GPIO32
      mode:
        input: true
        pullup: true
    on_anticlockwise:
      then:
        - lambda: |-
                id(Vol) -= 0.02;
                if(id(Vol) < 0) id(Vol) = 0;
                id(volume_display_active) = true;
                id(volume_display_timer) = 0;
        - script.execute: volume_display                          
        - media_player.volume_set:
                id: manga_media_player
                volume: !lambda return id(Vol);
#        - script.execute: schedule_volume_update
    on_clockwise:
      then:
        - lambda: |-
                id(Vol) += 0.02;
                if(id(Vol) > 1) id(Vol) = 1;
                id(volume_display_active) = true;
                id(volume_display_timer) = 0;
        - script.execute: volume_display                          
        - media_player.volume_set:
                id: manga_media_player
                volume: !lambda return id(Vol);
#        - script.execute: schedule_volume_update
  - platform: adc
    pin: GPIO33
    name: Battery voltage
    device_class: voltage
    unit_of_measurement: "V"
    accuracy_decimals: 2
    state_class: measurement
    entity_category: diagnostic
    update_interval: 15s
    attenuation: auto
    filters:
      - multiply: 2 # https://forum.raspiaudio.com/t/esp-muse-luxe-bluetooth-speaker/294/12
      - exponential_moving_average:
          alpha: 0.2
          send_every: 2
      - delta: 0.002
    on_value:
      then:
        - sensor.template.publish:
            id: battery_percent
            state: !lambda "return x;"

  - platform: template
    name: Battery
    id: battery_percent
    device_class: battery
    unit_of_measurement: "%"
    accuracy_decimals: 0
    state_class: measurement
    entity_category: diagnostic
    update_interval: 15s
    filters:
      - calibrate_polynomial:
          degree: 3
          datapoints:
            - 4.58 -> 100.0
            - 4.5 -> 97.1
            - 4.47 -> 94.2
            - 4.44 -> 88.4
            - 4.42 -> 82.7
            - 4.41 -> 76.9
            - 4.41 -> 71.1
            - 4.37 -> 65.3
            - 4.35 -> 59.5
            - 4.31 -> 53.8
            - 4.28 -> 48.0
            - 4.26 -> 42.2
            - 4.23 -> 36.4
            - 4.21 -> 30.6
            - 4.19 -> 24.9
            - 4.16 -> 19.1
            - 4.1 -> 13.3
            - 4.07 -> 10.4
            - 4.03 -> 7.5
            - 3.97 -> 4.6
            - 3.82 -> 1.7
            - 3.27 -> 0.0
      - lambda: return clamp(x, 0.0f, 100.0f);   
                  
                   
binary_sensor:      
  - platform: gpio
    pin:
      number: GPIO00
      inverted: true
      mode:
        input: true
        pullup: true 
    name: Mute
    on_click:       
      - script.execute: manual_listen
    on_double_click:
       - if:
           condition: 
              - lambda: 'return(id(phase) == 2);'
           then:
              - media_player.stop:                     


light:
  - platform: esp32_rmt_led_strip
    name: None
    id: top_led
    pin: GPIO22
    chipset: WS2812
    num_leds: 1
    rgb_order: grb
#    rmt_channel: 0
    default_transition_length: 0s
    gamma_correct: 2.8
    effects:
      - pulse:
          name: pulse
          transition_length: 250ms
          update_interval: 250ms
      - pulse:
          name: slow_pulse
          transition_length: 1s
          update_interval: 2s

    
i2s_audio:
    id: i2s0
    i2s_lrclk_pin: GPIO25
    i2s_bclk_pin: GPIO5
#    i2s_mclk_pin: GPIO0

microphone:
  - platform: i2s_audio
    id: manga_mic
    i2s_audio_id: i2s0
    sample_rate: 16000
    i2s_din_pin: GPIO35
    bits_per_sample: 24bit
    channel: right
    adc_type: external
    mclk_multiple: 384

    
    
speaker:
  - platform: i2s_audio
    id: manga_speaker
    i2s_audio_id: i2s0
    i2s_dout_pin: GPIO26
    dac_type: external
    sample_rate: 48000
    bits_per_sample: 16bit
    num_channels: 1
    buffer_duration: 100ms     
    
media_player:
  - platform: speaker
    name: None
    id: manga_media_player
    internal: false   
#    task_stack_in_psram: true
#    volume_min: 0.5
#    volume_max: 0.8
    announcement_pipeline:
      speaker: manga_speaker
      format: WAV
      sample_rate: 48000
      num_channels: 1       
    files:
      - id: little_sound
        file: https://github.com/RASPIAUDIO/esphomeLuxe/raw/refs/heads/main/wav/sounds_timer_finished.wav                
    on_announcement: 
      - micro_wake_word.stop:
      - wait_until:
          not:
            micro_wake_word.is_running:
      - microphone.mute: manga_mic
      - lambda: |-
          id(audio_active) = true;
          id(audio_started) = false;
      - if:
           condition:
                lambda: 'return(id(phase) != 2);'
           then:           
              - lambda: |-
                   if(id(phase) == 1)  id(phase) = 2;    
              - script.execute: mute_off         
              - script.execute: update_led    
                     
    on_idle:
      - if:
          condition:
            lambda: 'return id(audio_active) && id(audio_started);'
          then:
            - wait_until:
               and:
                - not:
                    media_player.is_announcing:
                - not:
                    voice_assistant.is_running:    
            - if:
                condition:              
                    lambda: 'return((id(phase) == 4) || (id(phase) == 2));'
                then:
                  - lambda: |-
                       id(phase) = 1; 
            - microphone.unmute: manga_mic
            - micro_wake_word.start:                                              
            - script.execute: update_led
            - lambda: |-
                id(audio_active) = false;
                id(audio_started) = false;
    on_play:
      - if:
          condition:
            lambda: 'return !id(mute);'
          then:
            - output.turn_off: dac_mute
            - lambda: id(muteH) = false;
      
select:
  - platform: template
    name: "Wake word sensitivity"
    optimistic: true
    initial_option: Slightly sensitive
    restore_value: true
    entity_category: config
    options:
      - Slightly sensitive
      - Moderately sensitive
      - Very sensitive
    on_value:
      # Adjust model probability thresholds to tune wake word sensitivity
      lambda: |-
        if (x == "Slightly sensitive") {
          id(okay_nabu).set_probability_cutoff(217);    // 0.85 -> 0.000 FAPH on DipCo
          id(hey_jarvis).set_probability_cutoff(247);   // 0.97 -> 0.563 FAPH on DipCo
          id(hey_mycroft).set_probability_cutoff(253);  // 0.99 -> 0.567 FAPH on DipCo
        } else if (x == "Moderately sensitive") {
          id(okay_nabu).set_probability_cutoff(176);    // 0.69 -> 0.376 FAPH on DipCo
          id(hey_jarvis).set_probability_cutoff(235);   // 0.92 -> 0.939 FAPH on DipCo
          id(hey_mycroft).set_probability_cutoff(242);  // 0.95 -> 1.502 FAPH on DipCo
        } else if (x == "Very sensitive") {
          id(okay_nabu).set_probability_cutoff(143);    // 0.56 -> 0.751 FAPH on DipCo
          id(hey_jarvis).set_probability_cutoff(212);   // 0.83 -> 1.502 FAPH on DipCo
          id(hey_mycroft).set_probability_cutoff(237);  // 0.93 -> 1.878 FAPH on DipCo
        }


voice_assistant:
  id: va
  microphone: manga_mic
  media_player: manga_media_player
  micro_wake_word: mww
  use_wake_word: false
  noise_suppression_level: 2
  auto_gain: 31dBFS
  volume_multiplier: 2.0
  
  on_listening: 
     - logger.log: "listening 3 => phase"                    
     - micro_wake_word.stop:
     - lambda: |-
        id(phase) = 3;                            
     - script.execute: update_led

  on_stt_end:
     - light.turn_on:
        id: top_led
        blue: 60%
        red: 20%
        green: 20%
        effect: pulse
      

  on_tts_start:
    - logger.log: "answering  4 => phase"                   
    - micro_wake_word.stop:
    - wait_until:
        not:
          micro_wake_word.is_running:
    - microphone.mute: manga_mic
    - lambda: |-
        id(audio_active) = true;
        id(audio_started) = false;
    - lambda: |-
        id(phase) = 4;
    - script.execute: update_led
                     
  on_error:
    - logger.log: "ERROR!!!!!!!!!!!!!!!!"  
    - light.turn_on:
        id: top_led
        blue: 0%
        red: 100%
        green: 0%
        effect: pulse          
    - delay: 3s
    - lambda: id(phase) = 1;    
    - script.execute: update_led 
  

#########
# Scripts

script:   

  - id: manual_listen
    then:
      - logger.log: "Manual listen button pressed"
      - if:
          condition:
            lambda: 'return id(mute);'
          then:
            - logger.log: "Manual listen -> unmute and go to waiting"
            - script.execute: mute_off
            - voice_assistant.stop:
            - wait_until:
                not:
                  voice_assistant.is_running:
            - micro_wake_word.start:
            - lambda: |-
                 id(audio_active) = false;
                 id(audio_started) = false;
                 id(phase) = 1;
            - script.execute: update_led
          else:
            - if:
                condition:
                  lambda: 'return id(phase) == 2;'
                then:
                  - logger.log: "Manual listen -> mute current playback"
                  - script.execute: mute_on
                else:
                  - if:
                      condition:
                        lambda: 'return id(phase) == 1;'
                      then:
                        - logger.log: "Manual listen -> switch waiting to listening"
                        - voice_assistant.stop:
                        - wait_until:
                            not:
                              voice_assistant.is_running:
                        - script.execute: mute_off
                        - microphone.unmute: manga_mic
                        - micro_wake_word.stop:
                        - lambda: |-
                             id(audio_active) = false;
                             id(audio_started) = false;
                             id(phase) = 3;
                        - script.execute: update_led
                        - voice_assistant.start:
                      else:
                        - if:
                            condition:
                              lambda: 'return id(phase) == 3;'
                            then:
                              - logger.log: "Manual listen -> switch listening to waiting"
                              - voice_assistant.stop:
                              - wait_until:
                                  not:
                                    voice_assistant.is_running:
                              - micro_wake_word.start:
                              - lambda: |-
                                   id(audio_active) = false;
                                   id(audio_started) = false;
                                   id(phase) = 1;
                              - script.execute: update_led
                            else:
                              - logger.log: "Manual listen -> fallback to waiting"
                              - voice_assistant.stop:
                              - wait_until:
                                  not:
                                    voice_assistant.is_running:
                              - micro_wake_word.start:
                              - lambda: |-
                                   id(audio_active) = false;
                                   id(audio_started) = false;
                                   id(phase) = 1;
                              - script.execute: update_led


  - id: update_led
    then:  
       - if:
           condition:
             lambda: 'return id(phase) != id(last_led_phase);'
           then:
             - lambda: id(last_led_phase) = id(phase);
             - logger.log: "==>>>update_led" 
             - lambda: |-
                   if(id(phase) == 0)id(start).execute();
                   if(id(phase) == 1)id(waiting).execute();  
                   if(id(phase) == 2)id(external_player).execute();                      
                   if(id(phase) == 3)id(listening).execute();
                   if(id(phase) == 4)id(answering).execute();
                         
  - id: start           
    then:
     - light.turn_on:
          id: top_led
          effect: slow_pulse
          red: 80%
          green: 0%
          blue: 80%             
     - delay: 5sec
     - output.turn_off: dac_mute
     - lambda: id(phase) = 1;
     - micro_wake_word.stop:
     - wait_until:
         not:
           micro_wake_word.is_running:
     - microphone.mute: manga_mic
     - delay: 200ms
     - media_player.speaker.play_on_device_media_file:
          media_file: little_sound
          announcement: false     
     - lambda: |- 
            id(my_display).print(8, 20, id(my_font) , "RASPIAUDIO");      
     - delay: 2sec              
     - script.execute: update_led
     
  - id: waiting
    then:
     - light.turn_on:
          id: top_led
          effect: pulse
          red: 0%
          green: 0%
          blue: 100% 
          brightness: 100% 
     - lambda: |-
            id(my_display).clear();
            id(my_display).print(64, 25, id(my_font2) , TextAlign::CENTER, "Waiting");         
     - script.execute: volume_display                            
     - voice_assistant.stop:              
     - micro_wake_word.start:                       
       

  - id: listening
    then:
     - light.turn_on:
          id: top_led
          effect: pulse
          red: 0%
          green: 100%
          blue: 0%                      
          brightness: 100%    
     - lambda: |-
            id(my_display).clear();
            id(my_display).print(64, 25, id(my_font2) , TextAlign::CENTER, "Listening");    
     - script.execute: volume_display                    
          
  - id: answering
    then:
     - light.turn_on:
          id: top_led
          effect: none
          red: 100%
          green: 100%
          blue: 0%                     
          brightness: 100%    
     - lambda: |-
            id(my_display).clear();
            id(my_display).print(64, 25, id(my_font2) , TextAlign::CENTER, "Answering");                 
     - script.execute: volume_display          
               
  - id: external_player
    then:
     - light.turn_on:
          id: top_led
          effect: none
          red: 80%
          green: 40%
          blue: 0%                      
     - lambda: |-
            id(my_display).clear();
            id(my_display).print(64, 25, id(my_font2) , TextAlign::CENTER, "Playing");                          
     - script.execute: volume_display          
                             
  - id: mute_on
    then:
       - if:
           condition:
             lambda: 'return fabsf(id(last_volume_cmd)) > 0.005f;'
           then:
             - media_player.volume_set:
                 id: manga_media_player
                 volume: '0'
             - lambda: id(last_volume_cmd) = 0.0f;
       - lambda: id(mute) = true;
     
  - id: mute_off
    then:

       - if:
           condition:
             lambda: 'return fabsf(id(last_volume_cmd) - id(Vol)) > 0.005f;'
           then:
             - media_player.volume_set:
                  id: manga_media_player
                  volume: !lambda return(id(Vol));
             - lambda: id(last_volume_cmd) = id(Vol);
       - lambda: id(mute) = false;   
       
  - id: volume_display
    then:
       - lambda: |-
           id(my_display).filled_rectangle(14, 50, 100, 8, COLOR_OFF);
           id(my_display).rectangle(14, 50, 100, 8);   
           id(my_display).filled_rectangle(14, 50, id(Vol)*100, 8, COLOR_ON);              
            
      
      
                    
